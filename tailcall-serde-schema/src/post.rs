use std::{fmt::Formatter, marker::PhantomData};

use serde;
use serde::de;

#[derive(Debug)]
pub struct Post {
    pub user_id: u64,
    pub id: u64,
    pub title: String,
    pub body: String,
}

/// IMPORTANT: Do not delete this implementation.
/// This is the implementation of the Deserialize trait for the Post struct.
/// It was auto-generated by the derive macro and around 4x faster than the deserializer of serde_json::Value.
impl<'de> serde::Deserialize<'de> for Post {
    fn deserialize<D>(deserializer: D) -> serde::__private::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        enum Field {
            Field0,
            Field1,
            Field2,
            Field3,
            Field4,
        }

        struct FieldVisitor;
        impl<'de> de::Visitor<'de> for FieldVisitor {
            type Value = Field;
            fn expecting(&self, formatter: &mut Formatter) -> serde::__private::fmt::Result {
                Formatter::write_str(formatter, "field identifier")
            }
            fn visit_str<E>(self, value: &str) -> serde::__private::Result<Self::Value, E>
            where
                E: de::Error,
            {
                match value {
                    "user_id" => Ok(Field::Field0),
                    "id" => Ok(Field::Field1),
                    "title" => Ok(Field::Field2),
                    "body" => Ok(Field::Field3),
                    _ => Ok(Field::Field4),
                }
            }
        }

        impl<'de> serde::Deserialize<'de> for Field {
            #[inline]
            fn deserialize<D>(deserializer: D) -> serde::__private::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(deserializer, FieldVisitor)
            }
        }

        struct Visitor<'de> {
            marker: PhantomData<Post>,
            lifetime: PhantomData<&'de ()>,
        }
        impl<'de> de::Visitor<'de> for Visitor<'de> {
            type Value = Post;
            fn expecting(&self, formatter: &mut Formatter) -> serde::__private::fmt::Result {
                Formatter::write_str(formatter, "struct Post")
            }

            #[inline]
            fn visit_map<A>(self, mut map: A) -> serde::__private::Result<Self::Value, A::Error>
            where
                A: de::MapAccess<'de>,
            {
                let mut field0: serde::__private::Option<u64> = None;
                let mut field1: serde::__private::Option<u64> = None;
                let mut field2: serde::__private::Option<String> = None;
                let mut field3: serde::__private::Option<String> = None;
                while let Some(__key) = de::MapAccess::next_key::<Field>(&mut map)? {
                    match __key {
                        Field::Field0 => {
                            if serde::__private::Option::is_some(&field0) {
                                return serde::__private::Err(
                                    <A::Error as de::Error>::duplicate_field("user_id"),
                                );
                            }
                            field0 = Some(de::MapAccess::next_value::<u64>(&mut map)?);
                        }
                        Field::Field1 => {
                            if serde::__private::Option::is_some(&field1) {
                                return serde::__private::Err(
                                    <A::Error as de::Error>::duplicate_field("id"),
                                );
                            }
                            field1 = Some(de::MapAccess::next_value::<u64>(&mut map)?);
                        }
                        Field::Field2 => {
                            if serde::__private::Option::is_some(&field2) {
                                return serde::__private::Err(
                                    <A::Error as de::Error>::duplicate_field("title"),
                                );
                            }
                            field2 = Some(de::MapAccess::next_value::<String>(&mut map)?);
                        }
                        Field::Field3 => {
                            if serde::__private::Option::is_some(&field3) {
                                return serde::__private::Err(
                                    <A::Error as de::Error>::duplicate_field("body"),
                                );
                            }
                            field3 = Some(de::MapAccess::next_value::<String>(&mut map)?);
                        }
                        _ => {
                            let _ = de::MapAccess::next_value::<de::IgnoredAny>(&mut map)?;
                        }
                    }
                }
                let __field0 = match field0 {
                    Some(__field0) => __field0,
                    None => serde::__private::de::missing_field("user_id")?,
                };
                let __field1 = match field1 {
                    Some(__field1) => __field1,
                    None => serde::__private::de::missing_field("id")?,
                };
                let __field2 = match field2 {
                    Some(__field2) => __field2,
                    None => serde::__private::de::missing_field("title")?,
                };
                let __field3 = match field3 {
                    Some(__field3) => __field3,
                    None => serde::__private::de::missing_field("body")?,
                };
                Ok(Post {
                    user_id: __field0,
                    id: __field1,
                    title: __field2,
                    body: __field3,
                })
            }
        }

        const FIELDS: &'static [&'static str] = &["user_id", "id", "title", "body"];
        serde::Deserializer::deserialize_struct(
            deserializer,
            "Post",
            FIELDS,
            Visitor { marker: PhantomData::<Post>, lifetime: PhantomData },
        )
    }
}

#[cfg(test)]
mod test {

    #[test]
    fn test_posts() {
        const JSON: &str = include_str!("../data/posts.json");
        let posts: Vec<super::Post> = serde_json::from_str(JSON).unwrap();

        assert_eq!(posts.len(), 100);
    }
}
